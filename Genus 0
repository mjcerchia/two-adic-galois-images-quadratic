/* The files pre.m, csg.m and csg24.dat are taken from Cummins-Pauli database of congruence subgroups available at
https://math-sites.uncg.edu/sites/pauli/congruence/  */

load ".../pre.m"; //Please change this according to your local directory.
load ".../csg.m"; 
load "csg24.dat"; 
filename:="CPdata.dat"; 
I:=Open(filename,"w"); 
WriteObject(I, L);

// Run this code in Magma from the directory this file is in.
cp_data:=[];
filename:="CPdata.dat";  
I:=Open(filename, "r"); 
_,cp_data:=ReadObjectCheck(I); 

// We only keep track of the entries that are useful for us.
CPRec := recformat< level, genus, index : RngIntElt,
                 matgens,
                name: MonStgElt>;
cp_data_new:=[];
for i in [1..#cp_data] do
    r:=cp_data[i];
    s:= rec<CPRec | level:=r`level, genus:=r`genus, index:=r`index, name:=r`name>;
    s`matgens:=[[Integers()!a:a in A] : A in r`matgens];
    cp_data_new:=cp_data_new cat [s];
end for;

CongSubgroup := recformat<N:RngIntElt, label:MonStgElt, gens:SeqEnum, index:RngIntElt, H:GrpMat>;

CPgenus0list:=AssociativeArray();


for r in cp_data_new do
    
    if #PrimeDivisors(r`level) eq 1 and r`genus eq 0 then 
    s`matgens:=[[Integers()!a:a in A] : A in r`matgens];
    CPgenus0list[r`name]:= rec<CongSubgroup | N:=r`level,  label:=r`name, gens:=s`matgens, index:=r`index>;
    end if;
    
end for;

keys:=[k: k in Keys(CPgenus0list)];
level:=[CPgenus0list[k]`N:k in keys];
ParallelSort(~level,~keys);
for k in keys do;
    Gamma:=CPgenus0list[k];	
	N:=Gamma`N;
	SL2:=SL(2,Integers(N));
	Gamma`H:=sub< SL2 | Gamma`gens cat [[-1,0,0,-1]]>;
    CPgenus0list[k] :=Gamma;
end for;


keys:=[k: k in Keys(CPgenus0list)];
level:=[CPgenus0list[k]`N:k in keys];
ParallelSort(~level,~keys);
for k in keys do;
SL2:=SL(2,Integers(CPgenus0list[k]`N));
    N:= Normalizer(SL2,CPgenus0list[k]`H);
    N1:=quo<N|CPgenus0list[k]`H>;
    s:=[];
    for n in N1 do;
        x:=0;
        t:=Factorisation(Order(n));
        // checking if for every p|Order(n) does p|CPlist[k]`N
        for p in t do;
            if CPgenus0list[k]`N mod p[1] eq 0 then x:=x+1; end if;
        end for;
        if x eq #t then s:=s cat [Order(n)];end if;
    end for;
    b:=Lcm(s);
    
   
    if ((CPgenus0list[k]`N) mod 2 eq 0 ) and ((CPgenus0list[k]`N) mod 4 ne 0) then
        b:=2*b;
    end if;
    k;b;
    print "...............";
end for;   

// Output

/*2A
4
...............
2B
2
...............
2C
4
...............
3B
1
...............
3C
1
...............
3D
3
...............
3A
3
...............
4A
1
...............
4B
2
...............
4D
2
...............
4E
2
...............
4F
2
...............
4G
4
...............
4C
2
...............
5A
1
...............
5B
1
...............
5F
1
...............
5H
5
...............
5D
1
...............
5C
1
...............
5E
1
...............
5G
1
...............
7F
1
...............
7A
1
...............
7C
1
...............
7D
1
...............
7G
1
...............
7B
1
...............
7E
1
...............
8A
2
...............
8L
2
...............
8K
2
...............
8G
4
...............
8H
2
...............
8P
2
...............
8C
2
...............
8M
2
...............
8N
8
...............
8E
2
...............
8D
2
...............
8B
4
...............
8I
2
...............
8O
4
...............
8F
1
...............
8J
2
...............
9A
1
...............
9D
3
...............
9J
3
...............
9I
3
...............
9H
3
...............
9C
3
...............
9G
1
...............
9F
1
...............
9E
1
...............
9B
3
...............
11A
1
...............
13A
1
...............
13B
1
...............
13C
1
...............
16B
8
...............
16G
8
...............
16E
2
...............
16H
2
...............
16C
4
...............
16F
4
...............
16D
2
...............
16A
2
...............
25A
1
...............
25B
5
...............
27A
3
...............
32A
8
...............*/
//*********************************************************************
//We now produce labels of all genus 0 prime power level modular curves that contain $-I$ and have full determinant using LMFDB data. 
load "lmfdb_gps_gl2zhat_fine_1213_1923 (1).m";
genus0:=[];
for tuple in data do;
label:=tuple[1];
g:=Split(label,".")[3];
if g eq "0" then 
genus0:=genus0 cat [label];
end if;
end for;
#genus0; //265

