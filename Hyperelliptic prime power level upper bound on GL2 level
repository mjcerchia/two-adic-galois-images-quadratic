//The following set is taken from Zywina's "Classification of low gonality modular curves" paper.

// Every genus 2 congruence subgroup is geometrically hyperelliptic so we have not included them in this list.

gonality_equals_2:=[ "8B3", "10B3", "12C3", "12D3", "12E3", "12F3", "12G3", "12H3", "12K3", 
    "12L3", "14A3", "14C3", "14F3", "15F3", "15G3", "16B3", "16C3", "16D3", "16E3", "16F3", 
    "16I3", "16J3", "16M3", "16S3", "18A3", "18C3", "18F3", "18G3", "20C3", "20F3", "20G3", 
    "20H3", "20I3", "20J3", "20M3", "20O3", "21A3", "21B3", "21D3", "24A3", "24B3", "24C3", 
    "24G3", "24I3", "24K3", "24L3", "24M3", "24S3", "24U3", "24V3", "24W3", "28C3", "28E3", 
    "30B3", "30G3", "30J3", "30K3", "30L3", "32B3", "32C3", "32D3", "32H3", "32K3", "32M3", 
    "33C3", "34B3", "35A3", "36E3", "36F3", "36G3", "39A3", "40D3", "40E3", "40F3", "40I3", 
    "41A3", "42E3", "48C3", "48E3", "48F3", "48H3", "48I3", "48J3", "48M3", "50A3", "54A3", 
    "60C3", "60D3", "64A3", "96A3", "18B4", "25A4", "25D4", "32B4", "36C4", "42A4", "44B4", 
    "47A4", "48C4", "50A4", "50D4", "10A5", "14C5", "16G5", "18A5", "24A5", "24D5", "26A5", 
    "30C5", "30F5", "36A5", "36B5", "36H5", "40A5", "42A5", "44B5", "45A5", "45C5", "46A5", 
    "48A5", "48E5", "48F5", "48G5", "48H5", "50A5", "50D5", "50F5", "52B5", "54A5", "57A5", 
    "58A5", "59A5", "60A5", "96A5", "48A6", "71A6", "32E7", "48N7", "56B7", "64D7", "82B7", 
    "96A7", "93A8", "50A9", "50D9", "96B9", "48B11", "72A11", "96B11"];
/* The files pre.m, csg.m and csg24.dat are taken from Cummins-Pauli database of congruence subgroups available at
https://math-sites.uncg.edu/sites/pauli/congruence/ and does not contain genus 2 congruence subgroups.*/

load ".../pre.m"; //Please modify these according to the local directory.
load ".../csg.m"; 
load "csg24.dat"; 
filename:="CPdata.dat"; 
I:=Open(filename,"w"); 
WriteObject(I, L);

// Run this code in Magma from the directory this file is in.
cp_data:=[];
filename:="CPdata.dat";  
I:=Open(filename, "r"); 
_,cp_data:=ReadObjectCheck(I); 

// We only keep track of the entries that are useful for us.
CPRec := recformat< level, genus, index : RngIntElt,
                 matgens,
                name: MonStgElt>;
cp_data_new:=[];
for i in [1..#cp_data] do
    r:=cp_data[i];
    s:= rec<CPRec | level:=r`level, genus:=r`genus, index:=r`index, name:=r`name>;
    s`matgens:=[[Integers()!a:a in A] : A in r`matgens];
    cp_data_new:=cp_data_new cat [s];
end for;

CongSubgroup := recformat<N:RngIntElt, label:MonStgElt, gens:SeqEnum, index:RngIntElt, H:GrpMat>;

CPgenus2list:=AssociativeArray();
CPgenus3list:=AssociativeArray();
CPgenus4list:=AssociativeArray();
CPgenus5list:=AssociativeArray();
CPgenus6list:=AssociativeArray();
CPgenus7list:=AssociativeArray();

for r in cp_data_new do
    
    if #PrimeDivisors(r`level) eq 1 and r`genus eq 2 then 
    s`matgens:=[[Integers()!a:a in A] : A in r`matgens];
    CPgenus2list[r`name]:= rec<CongSubgroup | N:=r`level,  label:=r`name, gens:=s`matgens, index:=r`index>;
    end if;
    
end for;

for r in cp_data_new do
    
    if #PrimeDivisors(r`level) eq 1 and r`genus eq 3 and r`name in gonality_equals_2 then 
    s`matgens:=[[Integers()!a:a in A] : A in r`matgens];
    CPgenus3list[r`name]:= rec<CongSubgroup | N:=r`level,  label:=r`name, gens:=s`matgens, index:=r`index>;
    end if;
end for;

 
 for r in cp_data_new do
    
    if #PrimeDivisors(r`level) eq 1 and r`genus eq 4 and r`name in gonality_equals_2 then 
    s`matgens:=[[Integers()!a:a in A] : A in r`matgens];
    CPgenus4list[r`name]:= rec<CongSubgroup | N:=r`level,  label:=r`name, gens:=s`matgens, index:=r`index>;
    end if;
end for;
 
 
for r in cp_data_new do
    
    if #PrimeDivisors(r`level) eq 1 and r`genus eq 5 and r`name in gonality_equals_2 then 
    s`matgens:=[[Integers()!a:a in A] : A in r`matgens];
    CPgenus5list[r`name]:= rec<CongSubgroup | N:=r`level,  label:=r`name, gens:=s`matgens, index:=r`index>;
    end if;
end for;

 
for r in cp_data_new do
    
    if #PrimeDivisors(r`level) eq 1 and r`genus eq 6 and r`name in gonality_equals_2 then 
    s`matgens:=[[Integers()!a:a in A] : A in r`matgens];
    CPgenus6list[r`name]:= rec<CongSubgroup | N:=r`level,  label:=r`name, gens:=s`matgens, index:=r`index>;
    end if;
end for;

 
 for r in cp_data_new do
    
    if #PrimeDivisors(r`level) eq 1 and r`genus eq 7 and r`name in gonality_equals_2 then 
    s`matgens:=[[Integers()!a:a in A] : A in r`matgens];
    CPgenus7list[r`name]:= rec<CongSubgroup | N:=r`level,  label:=r`name, gens:=s`matgens, index:=r`index>;
    end if;
end for;

keys:=[k: k in Keys(CPgenus2list)];
level:=[CPgenus2list[k]`N:k in keys];
ParallelSort(~level,~keys);
for k in keys do;
    Gamma:=CPgenus2list[k];	
	N:=Gamma`N;
	SL2:=SL(2,Integers(N));
	Gamma`H:=sub< SL2 | Gamma`gens cat [[-1,0,0,-1]]>;
    CPgenus2list[k] :=Gamma;
end for;

keys:=[k: k in Keys(CPgenus3list)];
level:=[CPgenus3list[k]`N:k in keys];
ParallelSort(~level,~keys);
for k in keys do;
    Gamma:=CPgenus3list[k];	
	N:=Gamma`N;
	SL2:=SL(2,Integers(N));
	Gamma`H:=sub< SL2 | Gamma`gens cat [[-1,0,0,-1]]>;
    CPgenus3list[k] :=Gamma;
end for;

keys:=[k: k in Keys(CPgenus4list)];
level:=[CPgenus4list[k]`N:k in keys];
ParallelSort(~level,~keys);
for k in keys do;
    Gamma:=CPgenus4list[k];	
	N:=Gamma`N;
	SL2:=SL(2,Integers(N));
	Gamma`H:=sub< SL2 | Gamma`gens cat [[-1,0,0,-1]]>;
    CPgenus4list[k] :=Gamma;
end for;

keys:=[k: k in Keys(CPgenus5list)];
level:=[CPgenus5list[k]`N:k in keys];
ParallelSort(~level,~keys);
for k in keys do;
    Gamma:=CPgenus5list[k];	
	N:=Gamma`N;
	SL2:=SL(2,Integers(N));
	Gamma`H:=sub< SL2 | Gamma`gens cat [[-1,0,0,-1]]>;
    CPgenus5list[k] :=Gamma;
end for;

keys:=[k: k in Keys(CPgenus6list)];
level:=[CPgenus6list[k]`N:k in keys];
ParallelSort(~level,~keys);
for k in keys do;
    Gamma:=CPgenus6list[k];	
	N:=Gamma`N;
	SL2:=SL(2,Integers(N));
	Gamma`H:=sub< SL2 | Gamma`gens cat [[-1,0,0,-1]]>;
    CPgenus6list[k] :=Gamma;
end for;

keys:=[k: k in Keys(CPgenus7list)];
level:=[CPgenus7list[k]`N:k in keys];
ParallelSort(~level,~keys);
for k in keys do;
    Gamma:=CPgenus7list[k];	
	N:=Gamma`N;
	SL2:=SL(2,Integers(N));
	Gamma`H:=sub< SL2 | Gamma`gens cat [[-1,0,0,-1]]>;
    CPgenus7list[k] :=Gamma;
end for;

keys:=[k: k in Keys(CPgenus2list)];
level:=[CPgenus2list[k]`N:k in keys];
ParallelSort(~level,~keys);
for k in keys do;
SL2:=SL(2,Integers(CPgenus2list[k]`N));
    N:= Normalizer(SL2,CPgenus2list[k]`H);
    N1:=quo<N|CPgenus2list[k]`H>;
    s:=[];
    for n in N1 do;
        x:=0;
        t:=Factorisation(Order(n));
        // checking if for every p|Order(n) does p|CPlist[k]`N
        for p in t do;
            if CPgenus2list[k]`N mod p[1] eq 0 then x:=x+1; end if;
        end for;
        if x eq #t then s:=s cat [Order(n)];end if;
    end for;
    b:=Lcm(s);
    
   
    if ((CPgenus2list[k]`N) mod 2 eq 0 ) and ((CPgenus2list[k]`N) mod 4 ne 0) then
        b:=2*b;
    end if;
    k;b;
    print "...............";
end for;   

//*************************************************************

keys:=[k: k in Keys(CPgenus3list)];
level:=[CPgenus3list[k]`N:k in keys];
ParallelSort(~level,~keys);
for k in keys do;
SL2:=SL(2,Integers(CPgenus3list[k]`N));
    N:= Normalizer(SL2,CPgenus3list[k]`H);
    N1:=quo<N|CPgenus3list[k]`H>;
    s:=[];
    for n in N1 do;
        x:=0;
        t:=Factorisation(Order(n));
        // checking if for every p|Order(n) does p|CPlist[k]`N
        for p in t do;
            if CPgenus3list[k]`N mod p[1] eq 0 then x:=x+1; end if;
        end for;
        if x eq #t then s:=s cat [Order(n)];end if;
    end for;
    b:=Lcm(s);
    
   
    if ((CPgenus3list[k]`N) mod 2 eq 0 ) and ((CPgenus3list[k]`N) mod 4 ne 0) then
        b:=2*b;
    end if;
    k;b;
    print "...............";
end for;   

//**********************************************************************************

keys:=[k: k in Keys(CPgenus4list)];
level:=[CPgenus4list[k]`N:k in keys];
ParallelSort(~level,~keys);
for k in keys do;
SL2:=SL(2,Integers(CPgenus4list[k]`N));
    N:= Normalizer(SL2,CPgenus4list[k]`H);
    N1:=quo<N|CPgenus4list[k]`H>;
    s:=[];
    for n in N1 do;
        x:=0;
        t:=Factorisation(Order(n));
        // checking if for every p|Order(n) does p|CPlist[k]`N
        for p in t do;
            if CPgenus4list[k]`N mod p[1] eq 0 then x:=x+1; end if;
        end for;
        if x eq #t then s:=s cat [Order(n)];end if;
    end for;
    b:=Lcm(s);
    
   
    if ((CPgenus4list[k]`N) mod 2 eq 0 ) and ((CPgenus4list[k]`N) mod 4 ne 0) then
        b:=2*b;
    end if;
    k;b;
    print "...............";
end for;   

//**********************************************************************************

keys:=[k: k in Keys(CPgenus5list)];
level:=[CPgenus5list[k]`N:k in keys];
ParallelSort(~level,~keys);
for k in keys do;
SL2:=SL(2,Integers(CPgenus5list[k]`N));
    N:= Normalizer(SL2,CPgenus5list[k]`H);
    N1:=quo<N|CPgenus5list[k]`H>;
    s:=[];
    for n in N1 do;
        x:=0;
        t:=Factorisation(Order(n));
        // checking if for every p|Order(n) does p|CPlist[k]`N
        for p in t do;
            if CPgenus5list[k]`N mod p[1] eq 0 then x:=x+1; end if;
        end for;
        if x eq #t then s:=s cat [Order(n)];end if;
    end for;
    b:=Lcm(s);
    
   
    if ((CPgenus5list[k]`N) mod 2 eq 0 ) and ((CPgenus5list[k]`N) mod 4 ne 0) then
        b:=2*b;
    end if;
    k;b;
    print "...............";
end for;   

//*************************************************************************************

keys:=[k: k in Keys(CPgenus6list)];
level:=[CPgenus6list[k]`N:k in keys];
ParallelSort(~level,~keys);
for k in keys do;
SL2:=SL(2,Integers(CPgenus6list[k]`N));
    N:= Normalizer(SL2,CPgenus6list[k]`H);
    N1:=quo<N|CPgenus6list[k]`H>;
    s:=[];
    for n in N1 do;
        x:=0;
        t:=Factorisation(Order(n));
        // checking if for every p|Order(n) does p|CPlist[k]`N
        for p in t do;
            if CPgenus6list[k]`N mod p[1] eq 0 then x:=x+1; end if;
        end for;
        if x eq #t then s:=s cat [Order(n)];end if;
    end for;
    b:=Lcm(s);
    
   
    if ((CPgenus6list[k]`N) mod 2 eq 0 ) and ((CPgenus6list[k]`N) mod 4 ne 0) then
        b:=2*b;
    end if;
    k;b;
    print "...............";
end for;   

//*****************************************************************************************

keys:=[k: k in Keys(CPgenus7list)];
level:=[CPgenus7list[k]`N:k in keys];
ParallelSort(~level,~keys);
for k in keys do;
SL2:=SL(2,Integers(CPgenus7list[k]`N));
    N:= Normalizer(SL2,CPgenus7list[k]`H);
    N1:=quo<N|CPgenus7list[k]`H>;
    s:=[];
    for n in N1 do;
        x:=0;
        t:=Factorisation(Order(n));
        // checking if for every p|Order(n) does p|CPlist[k]`N
        for p in t do;
            if CPgenus7list[k]`N mod p[1] eq 0 then x:=x+1; end if;
        end for;
        if x eq #t then s:=s cat [Order(n)];end if;
    end for;
    b:=Lcm(s);
    
   
    if ((CPgenus7list[k]`N) mod 2 eq 0 ) and ((CPgenus7list[k]`N) mod 4 ne 0) then
        b:=2*b;
    end if;
    k;b;
    print "...............";
end for;   

// *****************************************************************************
// Output is as follows; an upper bound is SL_2 level * b

/*8A2
8
...............
8C2
2
...............
8B2
2
...............
9A2
3
...............
9B2
1
...............
11A2
1
...............
13A2
1
...............
16H2
2
...............
16F2
2
...............
16C2
8
...............
16A2
8
...............
16B2
2
...............
16L2
2
...............
16D2
2
...............
16E2
2
...............
16J2
4
...............
16K2
4
...............
16I2
4
...............
16G2
1
...............
19A2
1
...............
23A2
1
...............
25F2
1
...............
25D2
1
...............
25B2
1
...............
25C2
1
...............
25A2
1
...............
25E2
1
...............
27A2
3
...............
27B2
3
...............
29A2
1
...............
31A2
1
...............
32B2
4
...............
32A2
8
...............
32C2
4
...............
37A2
1
...............
64A2
4
...............
8B3
8
...............
16I3
8
...............
16D3
4
...............
16C3
4
...............
16J3
4
...............
16F3
2
...............
16E3
2
...............
16M3
2
...............
16B3
8
...............
16S3
4
...............
32C3
4
...............
32B3
8
...............
32M3
4
...............
32H3
2
...............
32K3
8
...............
32D3
4
...............
41A3
1
...............
64A3
8
...............
25D4
5
...............
25A4
5
...............
32B4
2
...............
47A4
1
...............
16G5
2
...............
59A5
1
...............
71A6
1
...............
32E7
8
...............
64D7
8
...............*/


// We now lower the GL_2 level for groups coming from 64A3 and 64D7.

function gl2DetIndex(H)
    M,pi:=MultiplicativeGroup(BaseRing(H));
    return Index(M,sub<M|[Inverse(pi)(Determinant(h)):h in Generators(H)]>);
end function;
function gl2Level(G)
    
    idx:=Index(GL(2,BaseRing(G)),G);
    if idx eq 1 then return 1; end if;
    P:=PrimeDivisors(#BaseRing(G));
    if #P eq 1 then
        m:=P[1];
        while Index(GL(2,Integers(m)),ChangeRing(G,Integers(m))) lt idx do m *:=P[1]; end while;
        return m;
    end if;
    return Min([m:m in Divisors(#BaseRing(G)) | m gt 1 and Index(GL(2,Integers(m)),ChangeRing(G,Integers(m))) eq idx]);
end function;
function gl2QImagesFromSL2(H)
    GL2:=GL(2,BaseRing(H));
    SL2:=SL(2,BaseRing(H));
    assert H subset SL2;
    N:=Normalizer(GL2,H);
    Q,pi:=quo<N|H>;
    // we are interested only in subgroups of Q that are isomorphic to the multiplicative group of Z/nZ
    m:=#MultiplicativeGroup(BaseRing(H));
    S:=[Inverse(pi)(K`subgroup) : K in Subgroups(Q:OrderEqual:=m,IsAbelian:=true)];
    return [G: G in S | gl2DetIndex(G) eq 1 and gl2Level(G) eq #BaseRing(H)];
end function;

N:=512;
H:=CPgenus3list["64A3"]`H;
red:=hom<SL(2,Integers(N))->SL(2,Integers(64))|[SL(2,Integers(64))!SL(2,Integers(N)).i:i in [1..#Generators(SL(2,Integers(N)))]]>;
Hred:=H@@red;
BaseRing(Hred);
gl2QImagesFromSL2(Hred); // empty so no groups of level 512

N:=512;
H:=CPgenus7list["64D7"]`H;
red:=hom<SL(2,Integers(N))->SL(2,Integers(64))|[SL(2,Integers(64))!SL(2,Integers(N)).i:i in [1..#Generators(SL(2,Integers(N)))]]>;
Hred:=H@@red;
BaseRing(Hred);
gl2QImagesFromSL2(Hred); // empty so no groups of level 512


